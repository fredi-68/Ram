This folder contains all external bot commands.
These commands use a "plug and play like" system, meaning that they can be switched in and out without having to reconfigure the server - a simple reboot is enough. This is usefull for streamlining the command line interface towards certain use cases and helps to provide a simpler, cleaner command system.

This is also where you can put your own custom commands. Yes, that's right: Because of the aforementioned "plug and play" architechture, any valid python file containing a command conforming to the external command API (see cmdsys.py for more information) placed in this folder will be automatically imported and included in the command system for use from the command line or chat interface.

The file cmdsys.py defines and exposes the external command API, which is documented below.

----------------------------------
INTRODUCTION
----------------------------------

This section describes the inner workings of the command system. You can skip it if you don't want to endure this short lesson in history relating to the development of this bot (which is totally understandable) but it does describe some interesting facts that may be relevant when developing new commands or especially, when debugging.

There was a time where every command was hardcoded into this bot. Yes, there were in fact endless amounts of if-elif-else clauses matching command patterns and parsing argument strings. Not only was this extremely uncomfortable to use, after I had implemented a few commands extending the list further got more and more complicated with the amount of code I had to sift through increasing ever so slightly.
As if that wasn't enough trouble already, almost every important command actually existed twice. YES, TWICE, IN THE SAME PROGRAM. You read correctly. This was because I had implemented the command line interface AFTER the first chat commands were already written and the new command line was, you guessed it, completely incompatible to the chat command interface. Instead of coming up with a better way to handle commands altogether, I decided to just implement every command twice - once for console and once for chat. This of course, while also being increadibly inefficient, caused the code to pile up twice as fast as well. On top of that, there was no guarantee that a command would be available on both interfaces. This was fine at first but when the time came to release version 2.0 I decided to put an end to this horror.
With version 2.0, the Unified Command System was introduced. This system had two purposes:

	- Make developing new commands faster, safer and most importantly easier

	- Provide ONE INTERFACE for both console and chat commands

This new interface worked great and commands could now be written using a simple object oriented development process which sped up production incredibly. However, there was still a problem: All commands were still located in the main file of the program, thus making said file incredibly hard to read or traverse. The obvious solution was to move every command to its own file, thus stripping the main file of about a third of its code. But a lot of the commands used references to objects in the global namespace. Dynamically adding all of those references to the command would be incredibly time consuming to do and it would also pose certain risks. Thus the command system was again separated. This time however, in INTERNAL and EXTERNAL commands.

	- INTERNAL commands are commands that rely very heavily on system internal functionality that can't be easily replaced.
	  These commands are hardcoded into the main program, thus having access to its global scope of variables and modules.
	  They are also initialized a little bit differently (you don't have to worry about this)

	- EXTERNAL commands are everything else. External commands provide a standardized API that abstracts most of the
	  command handling from the user. There are basic ways of input/output, configuration and access to other APIs.

Internal commands are loaded on startup, regardless of user configuration. If there is an error in an internal command, the whole bot comes tumbling down and crashes with a nasty error message. External commands are more tolerant than that. Even if the file is not an actual command, it won't crash the bot - it will just ignore it. So feel free to experiment.

This system has served me very well so far and I expect it to continue performing well for the goals I have with this bot.

----------------------------------
BEFORE YOU START
----------------------------------

Before starting work on custom commands, there are some things you may want to take care of first.

If you are doing any sort of development, you should enable debug logging on console. Not only will this log every tiny bit of information you DON'T need, but also provide detailed logging while commands
are being loaded and executed during the initialization phase. You can activate debug logging by changing the level of the console handler in config/logging.json. If you're willing to put the time in,
you can also set levels manually for all the different loggers (can be useful, especially if you just want those netcode messages to disappear). If you need more information or more time to read it,
everything is always written to the log file.

To get error logs and tracebacks delivered straight through Discord, you can enable command debugging in the bot config by setting the text of the config/bot/debug/showCommandErrors tag to 1.
Since this is a nonstandard configuration entry you may have to create the tag first.
Now any time a command fails to execute properly, you will receive a message with a traceback. This can help immensely, since the console log can advance very fast, especially in debug mode and error messages or tracebacks can be hard to read in time.

You will also want to familiarize yourself with the discord.py API, since a lot of the datatypes cmdsys uses are part of the library. There are also some things cmdsys cannot do, in which case
discord.py usually has your back. The client instance is exposed through an attribute as well as the original message. More on this later.

----------------------------------
THE COMMAND STRUCTURE
----------------------------------

Clearly the most interesting part of this whole thing since if you do this wrong your command won't be imported.

To write a module that contains a command you will need access to three things:

	- the class cmdsys.Command
	- the class cmdsys.Argument
	- the enum cmdsys.CmdTypes

The old CMD_TYPE_* constants are deprecated and should not be used any longer.
The easiest way to accomplish this is by calling

	from cmdsys import *

at the start of your module.
A command is defined by subclassing the Command class:

	class MyCommand(Command):

		pass

And we're done! You could put this file into the commands folder and the program would import your command and add it to the list.
As of version 5.0, the name of the command subclass doesn't matter anymore. The only thing of importance is that it is a subclass of Command.
You can even put multiple commands in the same file.
But if you expected a new command called "MyCommand" to magically show up in the command list you will be surprised:
There is not such command in the list.
This is because we haven't actually configured our command yet.

----------------------------------
THE setup() METHOD & COMMAND ATTRIBUTES
----------------------------------

To do this, we override the method Command.setup:

	class MyCommand(Command):

		def setup(self):

			self.name = "coolCommand"
			self.aliases.append("coolCmd")
			self.desc = "A cool command."

As you can see, we have supplied the command system with some additional information about our command. Let's walk you through the different attributes showcased here:

	name -		obvious naming is obvious: This attribute sets the name of the command. And not some internal name at
 			that. This is the default name used to refer to the command in the command interface. This means, you 
			can invoke this command by typing +[name] in chat or [name] on console, with [name] being the name 
			field we just defined.

	aliases - 	This attribute contains a list of other names the command may be referred to as. For example, we
			could call the command we made just now by typing +coolCommand OR +coolCmd in the chat: The
			behaviour will be exactly the same, although the actual name is the preferred way of referencing
			the command.

	desc - 		This attribute provides some space for you to tell your users what your command is actually supposed
			to accomplish. A good name for a command is already descriptive enough so that idealy no further
			explanation is needed as to its functionality but it is always nice to describe a command in more
			detail. This is also the place to put information or disclaimers about possible arguments (we'll
			get to those later).

Now we've made a command that we can even call from the chat using our own command name but it doesn't actually do anything yet... let's change that!

----------------------------------
THE call() METHOD & BASIC I/O
----------------------------------

Add the following method to your class to add some actual functionality:

	class MyCommand(Command):

		def setup(self):

			self.name = "coolCommand"
			self.aliases.append("coolCmd")
			self.desc = "A cool command."

		async def call(self, **kwargs):

			await self.respond("Hello World!")

HINT: If you don't know what those "async" and "await" directives are about, you should read the asyncio documentation and the python tutorials on asynchroneous programming. Basic knowledge of this is required to write commands (or at least understand what you're doing).

That's it, we've written our hello world program. Tricked you into it mate. Oh well, gotta stay within the conventions.

Now let's go over which part does what.
The call method is a callback coroutine that gets called by the command handler every time the command is invoked by the user. It's signature is actually very similar to the command itself. It takes one positional argument, which is the command instance. Additionally, the command handler may pass additional keyword arguments holding the values passed in by the user as arguments on the command interface. More on this later.
For now, let's look at the call inside the method. We call the self.respond method, which is a coroutine. This is how we interact with the user. We get our input from our arguments as defined and send our output with the Command.respond method. This method actually does quite a few things and if you read the introduction you'll know that it has to translate between different systems dynamically. But we don't have to deal with any of that, just passing a string as the first argument will do the right thing. There is one more convenience functionality included with Command.respond: By specifying a second argument you can control an optional mention to be sent with your message. This will only work if the command was issued through chat:

	await self.respond("Hi there") will result in the bot sending a message saying "Hi there" to the channel where the command was issued.
	await self.respond("Hi there",True) will do the same but it will prepend the user mention of the command author, which will look like this: "@username, Hi there"

This is nice because it gives you the option of integrating mention support without having to figure out where the message was sent from first.

----------------------------------
A QUICK EXAMPLE & ENVIRONMENT ATTRIBUTES
----------------------------------

So now we have the tools to do basic input and output. But most of the time, the command needs to SOMEHOW access the environment the command was issued in. Let's take, for example, a command that lists all online members of a server (bad idea, since for large servers this would result in quite a large list but for our example this will have to do). To accomplish this, we will need access to the following variables:

	- we need to know which server the command was issued from
	- we need to query that server for a list of all online members

Arguments won't help us here so we need to get the server instance from somewhere else. The way this is done in cmdsys is via environment attributes.
There are four such attributes:

	Command.client
	Command.config
	Command.responseHandle
	Command.msg

These attributes are None at the initialization stage of the Command so you can't use them in the setup method. But before a call is made to any interactive parts of the command (including the call method), these attributes are set by the command system to fit the current context.
client contains the current discord.Client instance, config the config.configManager instance, responseHandle the responseHandle instance for this call and msg the original discord.Message that contained the comand, or None if the command was issued through a console.
At this point you should familiarize yourself with the discord.py API if you haven't done so already. discord.Client and discord.Message and their respective attributes and methods are documented very well in discord.pys own documentation so I won't explain them any further.
config refers to the main config that stores all of the configuration information the bot manages. It reflects the contents of the file config/bot.xml and can change dynamically during a session (you can make changes to it as well).
responseHandle exposes the lower level implementation of the command interface. This thing does all the I/O work for us. It contains a few useful routines for checking where a message came from but for the most part we don't need to mess with it.
For our purpose of creating a member list command, we need access to the server the message was sent from. Luckily, Command.msg contains a reference to that very server. We just have to look up Command.msg.server.members to get a list of all members (or all online members if the member count is above 100).

So the code for our example command could look like this:

	class MyCommand(Command):

		def setup(self):

			self.name = "listUsers"
			self.desc = "This command lists all users that are online on this server."

		async def call(self, **kwargs):

			for member in tuple(self.msg.server.members):
				await self.respond(member.name)

It is worth noting that this would be an incredibly inefficient use of our I/O ressources. Every time the Command.respond() method is called, the message is sent to Discord via Client.send_message() IMMEDIATELY WITHOUT BUFFERING. This means for a long list like this, you will be sending potentially hundreds of messages... and there is not doubt that Discord won't like that very much. A smarter idea would be to buffer our responses. Incidentally, the respond() method takes an additional optional parameter called flush_chat, which is True by default. By setting this to False, we can tell the ResponseManager to buffer our messages until we call respond() with flush_chat=True, or call Command.flush() respectively.
The message buffering system is even smart enough to automatically handle character limits for you. If you try to send a message longer than 2000 characters, the ResponseManager will try to break that message up into smaller pieces, as long as it can find a place to do so. Breakpoints for messages include newlines and new messages.
The ResponseManager will automatically flush our message buffer if we forget to do so, however, WHEN this is going to happen is up to garbage collection, so it is best to always call flush() at the end of your command if you use manual message buffering.

So now we've discussed all major parts of our command system: Input, output and retrieving context information...
Wait a second, we never actually discussed how to get customized input using arguments right? Let's get to that as well before I forget again...

----------------------------------
ARGUMENTS
----------------------------------

Arguments are a very powerfull tool of cmdsys, because they allow you to customize your user interaction in a number of ways. The most basic way to add an Argument would be to do something like this:

	class MyCommand(Command):

		def setup(self):

			self.name = "echo"
			self.addArgument(Argument("message",CmdTypes.STR,True))

And that is it! A possible call method could look like this:

		async def call(self, message="", **kwargs):

			if not message:
				await self.respond("You didn't say anything :(")
			else:
				await self.respond(message)

This command would take a single optional argument (meaning that it can be ommitted) and prints the content of that argument into the chat. Let's take a closer look at the constructor call of Argument.
The first argument is the Argument name. This name is shown to the user in the command usage and help context and this is also the name of the keyword argument you will receive in the call method containing the argument the user entered.
The second argument is the Argument type. There are several predefined argument types that do certain things like automatic type checking and conversion. If you don't want this behavior, CmdTypes.STR will give you the original unaltered argument as typed by the user.
The third argument determines, if the Argument is optional or not. An optional Argument is NOT GUARANTEED to be included in the keyword argument list when call is... well.. called. This means your code has to account for this by, for example, specifying a default value for optional arguments or implement the necessary error handling. Take your pick.

Arguments are parsed, checked and converted automatically. There is, however, some special behaviour with Argument parsing one should be aware of. I will try to list all of those features here.

	- Arguments that specify an Argument type other than CmdTypes.STR will automatically be converted into that type.
	Handy! Be aware though, that this doesn't always work. Especially the discord internal types have some limitations, or
	sometimes can't be converted at all. If you are using these types, your code has to be able to handle strings as well
	or at least provide some useful error information if the user made a mistake. Otherwise your command will just fail 
	silently (appart from the obligatory error message in the logs). The standard Python types are pretty stable though and 
	can be expected to work as intended. If in doubt, always use CmdTypes.STR and do type conversion manually. Keep in mind 
	though that you may be missing out on special input methods like react or post selecting.

	- Arguments are passed as keyword only arguments to your call method. The command system makes no effort to check your
	method signature before calling, which can result in some nasty errors if too many arguments were passed (which can
	happen if you add an Argument in the setup method but forget to add it to call as well). This is why you see the
	**kwargs starred expression at the end of each call method signature in the examples; it is there to prevent excess
	arguments from crashing the command. The command parser will never pass more arguments in than you specified, so if you
	write your commands properly there should be no need for this precaution.

	- There is actually no such thing as "too many arguments" in cmdsys. Any excess arguments are merged and passed
	together with the last argument as a single value.

	- As of version 3.5, whitespaces in arguments can now be escaped by quoting the argument string (e.g.: "Hello World" will result in one argument with the value Hello World, regardless of position).
	This is made possible through the use of some fancy RE pattern matching, but you don't need to worry about that. However, this means that you cannot use quotes as part of input data in
	arguments anymore, since the parser will automatically match them to be the start of a compound argument. Even worse, if you miss the second quotation mark, some unexpected behaviour may
	occur. To address this issue, I plan to introduce a way to ESCAPE THE ESCAPE CHARACTER AS WELL. This will make the related code approximately 5 times more complicated.

	- As of CPython 3.6, the default dict implementation preserves argument passing order in keyword argument dicts. This means that kwargs will have all arguments in the same order they were
	defined in inside the setup() method. HOWEVER, one should not rely on this feature since the underlying implementation may change or be completely different on Python environments other
	than CPython, and this application will make no efforts in guaranteeing a certain order of arguments in the dict.

	- As stated earlier, the old CMD_TYPE_* constants are deprecated as of version 3.6 and should no longer be used. They are kept in for backwards compatibility but have been changed to reference
	the enum instead of integers.

----------------------------------
CONCLUSION
----------------------------------

With that we have reached the end of our documentation for the command system used in the ProtOS Discord Bot. You now know how to create a command from scratch, configure it, add functionality, provide interaction with the user and his/her environment and customize the interface to suit your needs.

There is still a lot more of the API that is exposed by cmdsys.py and also by the accompanying modules config.py, chatutils.py and ProtOS_Bot.py . You can read through those files yourself to figure out how to use the more advanced API features but this tutorial should get you off to a good start with writing your own command extensions for this bot. Don't forget: Behind the structural requirements and the specialized APIs, command files are still normal python modules which means you can define additional data structures, classes, funtions and variables. Think of the setup method as your programs main entrypoint and the call method as your event handler. With that you can extend the basic command system to interact with your own code, other libraries or even other services running on the machine or the internet.

If you still get stuck with something you can always check the commands I supplied with the bot. There are a bunch in the command folder already and you can examine or copy code to create new commands or figure out what is wrong with one you have already made. I didn't implement the API for fun after all, most if not all of the functions are used somewhere in those modules. So go ahead and have a look!

----------------------------------
APPENDIX A: DATABASES AND DATA PERSISTENCE
----------------------------------

With version 3.3, I introduced a new data persistency model using sqlite3: The DatabaseManager.
The DatabaseManager, DatabaseHandle and Dataset classes are implemented in the config.py module, refer to the source for more in depth documentation.

First question you SHOULD have is "why should I use this instead of the configManager to store information?" Good question. Here's why:

	-The configManager was originally designed to store information that is relevant for the bot itself and is REQUIRED for it to function properly. However,
	 due to lack of a better alternative, any data that was PRODUCED by the bot at runtime was also stored in said config, which made it quite convoluted and hard to read.
	 Thus, with the introduction of the DatabaseManager, all configuration data should be stored using the configManager and all dynamically generated data should be
	 organized using the DatabaseManager instead.

	-The DatabaseManager was designed to handle large, organized datasets. It is running on a fast and reliable sqlite3 backend and provides automatic caching and
	 structuring of data over multiple servers. Thus, your applications don't have to worry about DIFFERENT SERVERS anymore, since each server is assigned its own
	 separate database.

	-The configManager required the ENTIRE FILE to be rewritten to disk each time a part of the config was modified. On top of that, it was prone to security risks and
	 possible data corruption during saving. With the DatabaseManager, users can rely on sqlite3 to deal with these issues and just store and retrieve data like they
	 expect to.

Now, while this all sounds great and well, there are some limitations with this system:

	-There currently is (contrary to inline documentation) no way of accessing multiple Datasets from a query at once and perform operations on them. I have plans to introduce
	 a separate Query class that is returned by select calls INSTEAD of a Dataset, exposing direct access to the underlying Datasets and convenience functionality, but
	 currently the only way to select more than one entry is by using explicit row IDs.

	-This implementation has NOT been checked for reliable protection against SQL injections. While there are certain security precautions in place, you have full
	 responsibility of ensuring that no malicious data can be entered through your user interface. Accidentally executing arbitrary SQL statements or modifying
	 system tables may lead to limited functionality or complete system failure.

With all of this mess out of the way, here is how you access the database using the Command System API:

The DatabaseManager is responsible for creating and caching database instances and provides access to their respective DatabaseHandles. It can be accessed through the environmental attribute db.
To get the DatabaseHandle for a specific server, you have to call DatabaseManager.getServer(id), where id is the server ID. This call will return a DatabaseHandle instance.

	database = self.db.getServer(self.msg.server.id) #this would get the database corresponding to the server the command was executed in.

You may have noticed at this point that by specifying a fake server ID it would be possible to create arbitrarily named databases, and in fact, if you wanted to use such a database to store information server independent, you can, and absolutely should, use the "global" database. While the name obviously doesn't actually matter, it makes organizing information a lot easier if you keep to this convention. You obviously should store your command configuration using the configManager instead!

If you happen to receive a new database, it may be empty! This is why you should make sure any tables you may try to access actually exist before doing anything else:

	database.createTableIfNotExists("myTable", entries={"aString": "text"}, autocommit=True)

This will create a new table named "myTable" in the database that has the column "aString" of type text. The autocommit argument specifies if the generated SQL statement should be executed immediately or commited later. This can be useful if many statements need to be executed after each other, but can be omitted in most cases since it defaults to True.
FOR SECURITY REASONS ONE SHOULD AVOID USING USER INPUT AS PART OF THE TABLE NAME AS IT MAY OPEN UP YOUR COMMAND/APPLICATION TO SQL INJECTION VULNERABILITIES!!!

There are some tables that are created inside any new database automatically. These special tables usually have some connection to internal mechanics. DO NOT TRY TO ALTER OR DELETE THESE TABLES OR THEIR DATA, UNLESS YOU KNOW WHAT YOU ARE DOING. You might break the bot otherwise.
Automatically created tables include:

	blockedChannels - stores information about channels the AI is not allowed to read from or write to.
	blockedUsers - lists users that have been blocked from using any bot commands.
	pinChannels - lists channels that are used to store pinned messages.
	tasks - stores information about tasks. Currently not being used.

With our new DatabaseHandle we have direct access to the database. While the DatabaseHandle provides very thin wrapper methods around a sqlite3 Cursor object, there is another, more object oriented way of accessing data in the database. This is done through Datasets.
To create a new Dataset you do the following:

	dataset = database.createDataset("myTable")

This call will create a new Dataset in the table "myTable" and return its corresponding Dataset instance. This does, however, not write the new Dataset to the database immediately. Thus, after this call, the returned Dataset is NOT ACTUALLY IN THE DATABASE!!!
If it is required to query for a certain dataset that may already exist, one can use DatabaseHandle.createDatasetIfNotExists():

	dataset = database.createDatasetIfNotExists("myTable", {"aString": "Hi There"})

This call will return the first Dataset that matches the requirements (aka, has the string "Hi There" set in column "aString"). The type and name of the columns depends on the table you query for the dataset. If no matching Dataset is found, a new one will be created. To check if the returned Dataset was found in the database, one can call the Dataset.exists() method.

Using the Dataset, parts of the corresponding database row can be modified and values can be retrieved. The database IS NOT ALTERED DURING ANY OF THIS. To commit any changes you made, call Dataset.update(). This call will automatically update the row if the Dataset already exists in the database or insert it otherwise. It should be noted that instead of using the provided convenience methods, one can also call many of them on DatabaseHandle instead, using the Dataset as an argument.

All SQL statements are logged during execution, so check the logfiles if anything weird is going on.

Neither DatabaseHandle nor DatabaseManager expose a clean up method to close open databases. This is intended and one should NEVER attempt to explicitly close a database connection. To ensure efficient data access and support a heavily asynchroneous program the DatabaseManager caches connected databases automatically. In case of system failure, any connections are implicitly closed and any uncommitted changes will be dropped. To ensure data consistency, it is sufficient to commit all changes made to the database before your command/application shuts down.

The DatabaseManager and all related systems are NOT THREAD SAFE. You should thus avoid interacting with the database outside of the main thread. If you absolutely need to, consider setting up a server using asyncios integrated features to handle database access for your application.

----------------------------------
APPENDIX B: CLEAN UP
----------------------------------

So, imagine the following scenario:

Your command enables users to query some information from a remote website and posts it into the chat. Because this command produces quite a lot of output you have it set up where any messages that are posted by it are autodeleted after a minute.
Now a bot administrator decides to conduct maintenance on the bot and shuts it down temporarily. There is, however, still a message in chat that will only be deleted in about 20 seconds. Luckily, you thought of that (well done) and set up a clean up handler in the destructor of your command that would delete all messages currently still being displayed if the object was GCed. Unfortunately, as your admin attempts to shut down the bot, it crashes with a nasty error message and the messages are still in the chat. What happened?

Implementing a clean up handler in a destructor doesn't always have the desired effect. This practice will create a race condition between the command and the discord client being GCed. If the discord client shuts down before the clean up method gets executed, deleting messages will obviously not work. How can we deal with this issue?

Since I had a similar problem while implementing the timeout command, I decided to introduce a clean up method registration function. To register a coroutine to be executed at bot shutdown, call

	cmdsys.cleanUpRegister(coro)

This will schedule coro to be run BEFORE the client terminates, guaranteeing that you will have full access to all features of the command system.
You may specify additional positional or keyword arguments. The coroutine will be called with these arguments in order of input.

All clean up methods will be executed FIFO. However, there is no guarantee that clean up methods registered by different commands will always be executed in the same order as well. YOU SHOULD NOT RELY ON THIS. If your clean up handler is state dependend, consider to store all relevant information inside your command instance.
There is currently no guarantee that clean up handlers will be executed if the bot crashed. In fairness, the APIs may not be available in this scenario anyways.

----------------------------------
APPENDIX C: DYNAMIC IMAGE CREATION AND MANIPULATION
----------------------------------

Again, imagine the following scenario:

Your command displays some information to the user. However, this information is very convoluted, complex or has properties that otherwise make it difficult to understand, especially in text form. You've considered using an embed to somewhat structure it better but this is still not what you wanted. If only there was a way of getting full control over the way discord displayed your message...

If you've read this far and now expect me to reveal that you can in fact gain complete control of the client UI, I'll have to disappoint you. However, what you COULD do is render the information as an image dynamically and then upload that as a file to discord. This is what this part of the documentation focuses on.

To dynamically create and manipulate images there are a couple of libraries that do a good job. There is, however, already a wrapper library included with the command system. It operates on the pygame multimedia/game development package that itself is a wrapper around the SDL multimedia library. To load and manipulate images using this wrapper you don't have to actually know how pygame or SDL work, but you will have to have the package installed. Since this is an optional module in the ProtOS Discord Bot distribution, its features may or may not be available to you depending on the platform/runtime environment. ALWAYS CHECK THE AVAILABILITY OF THE IMAGE MANIPULATION MODULES BEFORE YOU USE THEM OR YOUR CODE CAN CRASH AT RUNTIME.

To get access to the convenience functions, import the imagelib module. It is safe to do this regardless of package availability.
Before you can access any functions or classes in this module, you will have to call its init() function. This function will set up the modules components and initialize the pygame backend. If you are running pygame as a part of your main application (for example as part of another command) be aware that this call will reset the display mode so you may need to execute it in a different process.
If the init() call succeeds, all functions and classes in the imagelib module are now available.
To load an image, call imagelib.loadImage(path). Available file formats depend on the platform, but PNG and JPEG are usually supported. imagelib works with per pixel alpha by default so PNG alpha channels will be respected and converted correctly.
The imagelib.loadImage() function returns a new Image object. To manipulate the pygame surface directly, call Image.getSurface(). You should not attempt to manually alter the pixel format (depth or masks) since it could break the Image instance. Use of the Image.setSurface() method is thus discouraged. If you just want to put some text on an image, you can use Image.writeText() which abstracts most of the text render handling away from the user.
The Image class exposes a number of methods that mimic the behaviour of the pygame.Surface class, however, if you need more specific control over the surfaces or plan to use imagelib together with another library, you can set Image surfaces yourself. Just remember that you should always call imagelib.convert() on your surfaces before this, it will make sure that your surfaces have the correct pixel format.

To send the image off to discord you don't need to do anything, just pass the Image object to client.send_file() as the fp argument. imagelib will automatically convert your image into a PNG bytestream and send it to discord. To make it show up correctly, you should also specify a filename that ends with .png.

----------------------------------
APPENDIX D: LOGGING
----------------------------------

If you want to log information as your command is doing its thing, there is a logger attached to each command available through Command.logger. Its name is automatically set to the commands name. This
works for those cases where all you want is to display progress information on the console so you can tell what your command is doing during development. However, if you want to log a message to a
specific channel each time a command is executed; don't worry, we got a system for that.
The coroutine Command.log posts a message in all configured audit log channels. The bot has commands for managing audit log channels from the Discord client. The nice thing about this is that you don't
have to worry about setting up channel IDs or something similar. You can just use Command.log and it will work - on every server and every platform, as long as at least one logging channel is configured
for a server. If there is no such channel, the call does nothing.
However, to keep the spam down you should limit logging to security relevant information only. What does that mean exactly? Basically any action that has an impact on one or multiple members experience.
This includes things like timeouts, kicks, bans, changing role permissions, etc. Discord provides its own audit log by default, though you cannot write to it directly. Think of this feature as an
expandable alternative to that system. Try to view your command from an administrators perspective: What would you want to see, what would you consider unimportant?